<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[类加载NoSuchMethodError异常问题处理]]></title>
      <url>/jvm/2018/07/13/jvm-classload-priority/</url>
      <content type="text"><![CDATA[最近在开发环境中进行项目部署测试，再次遇一个鬼故事。项目maven打包正常，Tomcat上项目正常启动，但是在调用某个类的特定方法时，出现NoSuchMethodError异常，反编确认对应的JAR包中包含该类和对应的方法，但是JVM依旧报错。异常信息[ERROR] 15:35:43.751 c.c.m.o.e.GlobalExceptionHandler(31) - Handler dispatch failed; nested exception is java.lang.NoSuchMethodError: com.google.common.base.Splitter.splitToList(Ljava/lang/CharSequence;)Ljava/util/List;org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.NoSuchMethodError: com.google.common.base.Splitter.splitToList(Ljava/lang/CharSequence;)Ljava/util/List;        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:978)        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897)        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)        at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)        at javax.servlet.http.HttpServlet.service(HttpServlet.java:644)        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)        at javax.servlet.http.HttpServlet.service(HttpServlet.java:725)        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291)        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)        at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)异常分析项目是在尝试调用Google Guava Splitter中的splitToList方法时，发现该方法未定义。首先，项目编译时正常，所以在此过程中，是能找到对应的类和方法，那么为什么会出现在运行时找不到的情况呢？其次，抛出的异常是NoSuchMethodError，说明ClassLoader成功加载到了对应的类，只是在进行方法调用时，发现方法不存在。针对上面的分析，进行一些猜想的验证： 1.maven打包使用了低版本的Guava，而低版本中没有对应的方法 理论上来说，这种情况不太可能，如果使用了没有对应方法的低版本，那么打包编译是会失败的，实际上反编后，也是可以在对应的类中找到该方法的； 2.JAR冲突，导致使用了低版本的Guava，而低版本中没有对应的方法 然鹅，事实证明不是，maven依赖树中只出现了一个guava包的引用，所以排除这种情况； 3.Tomcat进行Class加载时，加载了低版本的Guava，而低版本中没有对应的方法 于是，我把项目打成了JAR，引入tomcat模块，放到测试环境中运行，一切正常~那么基本可以判断是和服务器Tomcat或JAVA环境有一定的关系，为了弄清楚在加载该类时，是从哪里加载的，在Tomcat启动参数中，加入-XX:+TraceClassLoading -XX:+TraceClassUnloading，用于跟踪Tomcat类加载和卸载，并在日志中进行查看，恩。。。然后发现：恩。。。。。。。恩。。。。。。。。恩。。。。。。。。。嘛玩意儿这是。。。。。根本就是不是从我的JAR包中加载的。。。。从上面的图可以看出，在进行Guava Splitter类加载的时候，从JRE的扩展LIB库中进行了该类的加载，那么为什么没有从项目包中加载，而是从扩展LIB库中进行加载的呢？可以看出，只有在项目部署在服务器Tomcat上的时候，才出现了相应的问题，那么很可能是和服务器中的Tomcat或JAVA环境有关。首先，我们来看一下Tomcat是如何做类加载和管理的。Tomcat使用一系列不同的ClassLoader来加载和管理一些基础的常规类，它们是能被所有WEB应用同时使用的，包括JVM的基础运行时类、Tomcat内部类等。而单个应用部署在Tomcat的独立容器中，每个容器中的WEB应用对应的ClassLoader相互隔离，以此来实现隔离。Tomcat中ClassLoader之间是呈现层级关系的，具体结构如下图所示：其中，Bootstrap class loader  用于加载JVM运行时基础类，同时也包含了扩展JAR包目录下的所有类（$JAVA_HOME/jre/lib/ext）；System class loader  一般从CLASSPATH环境变量中进行类初始化，所有的这些对于Tomcat内部类和WEB应用都是可见的。然后，标准的Tomcat启动脚本是会忽略CLASSPATH环境变量，而使用下列仓库进行代替： 1.$CATALINA_HOME/bin/bootstrap.jar  包含用于初始化Tomcat的所需类； 2.$CATALINA_BASE/bin/tomcat-juli.jar or $CATALINA_HOME/bin/tomcat-juli.jar  日志相关的实现类； 3.$CATALINA_HOME/bin/commons-daemon.jar  Apache Commons Daemon 中的类，Linux下可用于实现后台服务，Windows下可用于实现注册为系统服务。Common class loader  包含附加的类，对于Tomcat内部类和所有的WEB应用都是可见的，默认查找CATALINA_HOME和CATALINA_BASE目录下的lib目录；WebappX class loader  为每一个部署在Tomcat中WEB应用实例创建的ClassLoader，包括/WEB-INF/classes下所有解包的类和资源，同时也包含/WEB-INF/lib目录下JAR包中的类和资源。由于前三个ClassLoader是各个WEB应用通用的，当需要加载一个类时，会优先按顺序上最上层ClassLoader进行加载，当一个ClassLoader在对应的目录中没有找到对应的类时，就依次交给下一层级的ClassLoader进行加载。如果最终都没有找到对应的类，则抛出NoClassDefFoundError。综上所述，当尝试进行Google Guava Splitter类的加载时，首先交由Bootstrap class loader进行尝试性的加载，然后在对应目录中的JAR包中进行搜索时，居然从jre/lib/ext目录下的JAR包中找到了对应的类，所以优先进行了加载，而在对该JAR包进行反编后，发现确实包含了Google Guava，并且对应的Guava版本是14.0.1，而在对应的版本下，Guava Splitter确实还没有splitToList方法，所以最终导致类加载成功，但是找不到对应的方法，抛出NoSuchMethodError。异常原因当尝试进行Google Guava Splitter类的加载时，Bootstrap class loader优先找到并加载了低版本的Guava Splitter，而低版本中没有包含splitToList方法。后来在同事里问了一圈，发现是有同事之前测试，将测试JAR包放到了jre/lib/ext目录，导致了该问题的发生。解决方案      经确认后，将该JAR从扩展库目录中移除，处理后恢复正常；        禁止将业务JAR包放到JAVA库目录中，避免相关问题的再次发生；        在对模块进行JAR包封装，或进行SDK开发时，应尽可能较少相关第三方库依赖，避免与引用方依赖发生冲突；        如果无法避免引用第三方常用类库，可以使用maven shade插件，对相关第三方类库的包名进行变更，以此避免相关问题。  ]]></content>
      <categories>
        
          <category> JVM </category>
        
      </categories>
      <tags>
        
          <tag> JVM </tag>
        
          <tag> NoSuchMethodError </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[字符编码]]></title>
      <url>/common/mysql/2018/07/05/character-coding/</url>
      <content type="text"><![CDATA[ 字符、字符集和字符编码                    字符        基本信息单元，字母、数字和标点等                    字符集        字符集合，例如ASCII、GBK                    字符编码        字符集的二进制编码方式            那么问题来了，我们常说的ASCII、GBK等都是指字符编码，为什么被列入字符集里了？实际上对于大部分的字符集来说，一个字符集智慧有一套编码，所以字符集即唯一确定了其编码。但是凡事总有例外，UNICODE字符集就是一个特例，UNICODE存在多种编码方式，包括UTF-8、UTF-16等。常见字符编码ASCII单字节编码字符集，最高位不使用，常设为0.0~31及127为控制码，共33个32~126是字符，共95个空间占用：1字节不够用了怎么办 -&gt; LATIN-1（ISO-8859-1）ASCII扩展字符集，启用最高位。0~127位与ASCII相同，新开启的128~255收录新字符。空间占用：1字节有中文了怎么办 -&gt; GB2312有中文了怎么办？常用中文字符有6000多个~GB2312解决了中文问题，包含常用中文字符0~127位与ASCII相同，高位其他字符取消，采用新规则：当两个大于127的字符连在一起时，就表示一个汉字，前一个为高字节（0xA1到0xF7），后一个为低字节（0xA1到0xFE），可以组合出7000+的汉字。其中，高字节等于字符区号+0xA0，低字节等于字符所在区中的位置+0xA0。同时，GB2312也对一些特殊字符、数字和标点等进行了重新编码，重新编码的这一批字符，就是我们常说的“全角”字符，而127位以下的这些字符就被称为“半角”字符。哎呀，中文那么多不够用啊 -&gt; GBK基于GB2312进行扩展，不再要求低字节一定是127之后的编码，只要第一个字节是大于127的，那么代表这是一个汉字的开始。GBK包含了GB2312的所有内容，同时又增加了近20000个新的汉字。看一个例子：a机智采用GBK编码后，以十六进制方式查看，结果为：61bb fad6 c7第一个字节小于127，和ASCII编码保持一致，可以直接查表得到61对应a；之后一共4个字节，分别对应“机智”，查询后匹配bbfa对应”机“，d6c7对应”智”繁体字  -&gt; BIG5虽然GBK支持少量繁体中文，但是数量有限，于是就出现了BIG5啦。ISO表示我坐不住了 -&gt; UNICODE不同的国家，不同的语言，编码太多，就会出现兼容、转换等问题。这时候，ISO坐不住了。ISO统一了所有语言、字符和数字等编码，创建了UNICODE（Universal Multiple-Octet Coded Character Set），为了能够同时包含大量的字符，UNICODE使用2个字节来统一表示，对于ASCII中低于127位的字符保持不变，其他全部重新编码。前面有提到，UNICODE是字符集，并不能代表字符编码，UNICODE拥有多种编码方式，包括为UTF-8、UTF-16。（UCS Transfer Format，UCS是UNICDOE的简称）字符与字节不同的编码的字符串，其长度和大小怎么计算？字符串长度：字符串的实际长度，计算字符长度，strlen结果；字符串大小：字符串的空间占用大小，需要结合字符编码进行大小计算。MySQL下的字符编码show variables like ‘%character%’;                    character_set_client        客户端字符编码                    character_set_connection        网络传输数据的字符编码                    character_set_database        服务端数据字符编码                    character_set_filesystem        服务端文件名字符编码                    character_set_results        服务端返回结果集的字符编码                    character_set_server        服务端全局字符编码            MySQL字符集校对规则相同字符集内，字符比较和排序的规则。如果查看MySQL中，information_schema的CHARACTER_SETS，可以看到MySQL支持的字符集及其校对规则，例如：图中显示了MySQL支持的字符集，以及对应字符集的校对规则、字符集中字符的长度。其中，不同的校对规则，会以_ci、_cs、_bin结尾，分别代表了不同的比对模式，_ci为大小写不敏感，_cs为大小写敏感，_bin为二进制比对。MySQL表字符集修改修改表字符集（新数据生效）	ALTER TABLE  … CHARACTER SET …修改表字符集（新旧数据生效）	ALTER TABLE  … CONVERT TO CHARACTER SET …修改当前会话字符集	SET NAMES …（client、result、connection）]]></content>
      <categories>
        
          <category> Common </category>
        
          <category> MySQL </category>
        
      </categories>
      <tags>
        
          <tag> MySQL </tag>
        
          <tag> Character Coding </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ElasticSearch分组相关性写入]]></title>
      <url>/elasticsearch/2018/05/24/elasticsearch-group-write/</url>
      <content type="text"><![CDATA[随着业务发展，越来越多的业务数据接入到Elasticsearch集群中，基于ES的全文索引和聚合分析功能进行简单的数据分析和日志查找。在设计之初出于数据量和数据隔离的考虑，每个产品都以日期进行划分，生成数据索引。但是，随着新的产品越来越多，单个产品按日期划分，导致集群中的索引数量不断增加，ES集群的写入速度也越来越慢。起初我们对原因进行分析，认为是数据索引过多导致数据节点写入过慢。于是，在每天晚上定时对最近三天的数据进行分析，找出哪些产品的数据量比较小，并将数据量较小的数据索引进行合并，以减少索引数量；同时每天定时关闭一周前的数据索引转为冷数据，以减轻集群负担，使ES集群的写入和查询速度均得到提升。在持续稳定了一段时间后，写入速度又开始下降，只有正常情况下写入峰值的一半左右，而此时的索引数量仍在可接受的范围内，于是猜测写入较慢和索引数量之间的没有直接影响的关系，可能是与写入时的数据相关性有关。在进行数据写入时，由于数据本身基于产品进行划分，短时间大量不同产品数据的写入，会导致ES在处理一次数据提交时，需要将数据写入不同的索引。基于以上推测，我进行了一次关于数据相关性分组写入的测试。测试主要对相同总量，不同分组的数据进行写入测试，结果如下：宿主机环境                    CPU        4核                    内存        8G            组件配置                    组件        版本                            Docker        1.12.6                    Centos        Linux version 3.10.0­514.26.2.el7.x86_6                    Elasticsearch        6.1            ES参数配置                    参数        值                            ES数据节点数        1                    索引分片数        5                    分片副本数        1                    thread_pool.index.queue_size        1000                    thread_pool.index.size        5            写入策略                    参数        值                            数据总条数        20000                    写入次数        100                    单次批量写入数据量        200            测试方式  在写入数据量配置相同的情况下，调整一次提交中数据写入的索引数，即把单次批量写入的200条数据，写入到不同的N个索引中进行测试测试结果                    数据总数        写入次数        单次写入数据条数        写入索引数N        总耗时(ms)        单次批量写入平均耗时(ms)        单词批量写入最大耗时(ms)                            20000        100        200        100        135895        1358        4301                    20000        100        200        50        128403        1284        3716                    20000        100        200        25        70075        700        1577                    20000        100        200        10        34501        345        1062                    20000        100        200        1        11326        113        724            结果分析  从结果中可以明显看出，单次批量写入的数据中，最终需要写入的索引数N越小，写入速度越快。由此可以得出，在提交进行写入的数据中，数据分组相关性越高，最终写入的索引数越少，写入会越快。后记  后来基于这次的测试结果，我对数据写入的逻辑进行调整，将数据进行分组后写入，以此来提高数据分组相关性。但是从最终测试结果来看，实际数据写入速度并没有太明显的提升。对原因进行分析后，发现原因如下：  之前对数据量较少的产品数据索引进行合并，部分不同产品的数据已经是写入到同一个合并后的索引。而在实际场景中，大部分产品的数据量都是很小的，绝大部分的产品数据都是写入到这个合并索引中，所以从另一个角度上减少了单次数据提交所需要写入的索引数，导致优化数据写入后的效果并不明显。]]></content>
      <categories>
        
          <category> ElasticSearch </category>
        
      </categories>
      <tags>
        
          <tag> ElasticSearch </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Jar包变更导致JVM崩溃问题]]></title>
      <url>/jvm/2018/04/02/jvm-crash-when-jar-modify/</url>
      <content type="text"><![CDATA[最近部分线上JAVA项目和Tomcat出现无规律性崩溃，崩溃信息主要为：异常（一）JException in thread "data_send_thread_1" java.lang.NoClassDefFoundError: com/****/StreamResetException        ...        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)        ... 10 more或者异常（二）Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)J 128  java.util.zip.ZipFile.getEntry(J[BZ)J (0 bytes) @ 0x00007f62450db198 [0x00007f62450db140+0x58]J 103670 C2 sun.misc.URLClassPath$JarLoader.getResource(Ljava/lang/String;Z)Lsun/misc/Resource; (85 bytes)J 92261 C2 java.net.URLClassLoader$2.run()Ljava/lang/Object; (5 bytes) @ 0x00007f624b5aa3c0 [0x00007f624b5aa280+0x140]v  ~StubRoutines::call_stubJ 933  java.security.AccessController.doPrivileged(Ljava/security/PrivilegedAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;J 107440 C2 java.net.URLClassLoader.findResource(Ljava/lang/String;)Ljava/net/URL; (37 bytes) @ 0x00007f624df35394 [0x00007f624df35300+0x94]J 107175 C2 java.lang.ClassLoader.getResource(Ljava/lang/String;)Ljava/net/URL; (36 bytes) @ 0x00007f6249f14f28 [0x00007f6249f14da0+0x188]J 107117 C2 org.apache.catalina.loader.WebappClassLoaderBase.getResourceAsStream(Ljava/lang/String;)Ljava/io/InputStream; (354 bytes)J 107084 C2 org.apache.catalina.startup.ContextConfig.checkHandlesTypes(Lorg/apache/tomcat/util/bcel/classfile/JavaClass;)V (462 bytes)可以看出，崩溃原因均可归结为Class加载失败导致的，而加载的这个Class是一个JAVA Agent中的一个类。异常（一）：线程进行类加载时抛出当对象创建时，ClassLoader会先判断对象对应的类是否已经加载过，如果没有，则会优先进行加载。但在当前场景下，ClassLoader进行类加载时，抛出了NoClassDefFoundError异常。其中，NoClassDefFoundError与ClassNotFoundException是有区别的。ClassNotFoundException是在进行动态类加载时出现，往往实现不知道这个类是否存在，比如调用Class.forName，通过反射进行类加载时容易出现这个异常；NoClassDefFoundError遇到的并不多，一般是在编译时明确该类存在，但是在运行时进行加载的时候，找不到该类的定义。异常（二）：Tomcat类加载时抛出Tomcat作为Web应用容器，为每一个Web应用创建一个单独的WebAppClassLoader，用于加载这个应用所需要的类，同时也以此将不同项目所需要的类隔离开来。从异常信息可以看出，当ClassLoader尝试去加载一个类时，首先进行Jar包扫描，找到对应的Class在哪个Jar报中，然后通过特殊的权限控制方式，读取Jar包进行类加载。而Jar包本身以Zip格式为基础，所以通过ZipFile获取文件入口，而此时抛出异常。异常分析 1.  NoClassDefFoundError为JVM运行时异常，是在尝试加载Class时无法找到抛出的； 2.  对Tomcat源码进行调试，发现在AppClassLoader中，包含宝对应Java Agent的JAR包路径，并在加载过程中检查该JAR包中是否包含对应的Class，相关代码如下：URLClassLoader.javaprotected Class&lt;?&gt; findClass(final String name)    throws ClassNotFoundException{    final Class&lt;?&gt; result;    try {        result = AccessController.doPrivileged(            new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() {                public Class&lt;?&gt; run() throws ClassNotFoundException {                    String path = name.replace('.', '/').concat(".class");                    Resource res = ucp.getResource(path, false);                    if (res != null) {                        try {                            return defineClass(name, res);                        } catch (IOException e) {                            throw new ClassNotFoundException(name, e);                        }                    } else {                        return null;                    }                }            }, acc);    } catch (java.security.PrivilegedActionException pae) {        throw (ClassNotFoundException) pae.getException();    }    if (result == null) {        throw new ClassNotFoundException(name);    }    return result;}其中，ucp.getResource(path, false)尝试对指定类的ClassPath进行加载，遍历当前ClassLoader所包含的所有JAR包资源，利用ZipFile的getEntry方法，从jar包中搜索对应的Class信息，相关代码如下：ZipFile.java/** * Returns the zip file entry for the specified name, or null * if not found. * * @param name the name of the entry * @return the zip file entry, or null if not found * @throws IllegalStateException if the zip file has been closed */public ZipEntry getEntry(String name) {    if (name == null) {        throw new NullPointerException("name");    }    long jzentry = 0;    synchronized (this) {        ensureOpen();        jzentry = getEntry(jzfile, zc.getBytes(name), true);        if (jzentry != 0) {            ZipEntry ze = getZipEntry(name, jzentry);            freeEntry(jzfile, jzentry);            return ze;        }    }    return null;}正常情况下在JAVA Agent的JAR包中搜索，能找到对应的Class信息，即getEntry方法返回非0；而出现异常时，getEntry方法返回0。 3.  使用strace查看getEntry时对应的系统调用，结果如下：（1）Class加载成功时，可以从对应的JAR包中读取到Class信息（2）Class加载异常时，无法读取到Class信息可以看到在对JAR包中Class进行加载时，找不到对应的Class。但是，实际上使用解压或者使用JD-GUI查看其内容时，是能够找到编译后的Class文件，所以该类是存在的。那么问题来了，为什么明明有却会说找不到？问题原因最终，根据错误的异常信息，在Java官网找到了相似的异常，其实这是JAVA本身就存在的一个问题：ID 1296729.1Java Virtual Machine (JVM) crashes in java.util.zip.ZipFile.getEntry() during Class Loading (文档 ID 1296729.1） -  Random crashes during classloading while a jar/zip file is being accessed.  Here is a typical stack trace. Please notice that a custom classloader calls java.util.zip.ZipFile.getEntry() and the crash happens somewhere in libzip or libc or a native windows dll：tack: [0xfffffffe4e900000,0xfffffffe4e940000], sp=0xfffffffe4e93b1a0, free space=236kNative frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)C [libc_psr.so.1+0xbf4]C [libzip.so+0xe280]C [libzip.so+0x28e8]C [libzip.so+0x2d9c]J java.util.zip.ZipFile.getEntry(JLjava/lang/String;Z)JJ java.util.zip.ZipFile.getEntry(Ljava/lang/String;)Ljava/util/zip/ZipEntry;J weblogic.utils.classloaders.JarClassFinder.getSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;J weblogic.utils.classloaders.AbstractClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;J weblogic.utils.classloaders.MultiClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;J weblogic.utils.classloaders.MultiClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;J weblogic.utils.classloaders.MultiClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;j weblogic.application.utils.CompositeWebAppFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;J weblogic.utils.classloaders.MultiClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;J weblogic.utils.classloaders.MultiClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;j weblogic.utils.classloaders.CodeGenClassFinder.getClassSource(Ljava/lang/String;)Lweblogic/utils/classloaders/Source;j weblogic.utils.classloaders.GenericClassLoader.findLocalClass(Ljava/lang/String;)Ljava/lang/Class;j weblogic.utils.classloaders.GenericClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;j weblogic.utils.classloaders.ChangeAwareClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;J java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;J weblogic.utils.classloaders.ChangeAwareClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;j java.lang.ClassLoader.loadClassInternal(Ljava/lang/String;)Ljava/lang/Class;其中，三种情况可能导致该问题发生：There are three possible scenarios here:1. While a class is in use it is dynamically reloaded from a jar file.2. While a jar file is being accessed by the class loader, the jar file is being modified.3. A Jarfile which was bigger than 4GB was accessed (applies to Java 6 and earlier only)Please note that a crash may happen even a long time after a jarfile was modified as classloaders keep references to jarfiles.Another possible sceanrio is when Java or the application itself is being patched while the application is running.而这次问题的发生是由于第二点引起的，我们在对JAVA Agent版本进行更新时，是使用覆盖源文件的方式进行，随着Tomcat或者JVM重启去重新加载新的Agent JAR包。在更新JAR包，由于JVM还是保持着原JAR包的引用，所以再尝试从JAR包中进行Class加载时抛出异常，导致JVM崩溃。其中有一点比较关键的是，即使在JAR包变更后很长一段时间，也会出现这个问题，原因是因为在正常情况下，业务主要流程已经都跑过一次，依赖的类已经加载过，所以很少触发新的类加载，而当应用走到某个很少触发的业务逻辑或者抛出某个未加载过的异常，需要从该变更过的JAR包中进行Class加载时，就会产生这个现象。解决方案1. StackOverFlow中有大佬表示可通过升级使用JAVA 9来解决，JDK9 early access builds已经解决该问题。（https://stackoverflow.com/questions/38326183/jvm-crashed-in-java-util-zip-zipfile-getentry）2. 启动时关闭MemoryMapping。JAVA Bug Fixs - 6929479（http://www.oracle.com/us/technologies/java/overview-156328.html）]]></content>
      <categories>
        
          <category> JVM </category>
        
      </categories>
      <tags>
        
          <tag> JVM </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL Communications link failure问题]]></title>
      <url>/common/2016/12/10/mysql-communications-link-failure.md/</url>
      <content type="text"><![CDATA[最近对项目进行测试，突然出现Communications link failure异常，原文如下：```com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failureThe last packet successfully received from the server was 20,096 milliseconds ago.The last packet sent successfully to the server was 0 milliseconds ago.    at sun.reflect.GeneratedConstructorAccessor84.newInstance(Unknown Source) ~[?:?]    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[?:1.7.0_75]    ...```查看MySQL Status的Aborted_clients，变化如下：请求接口前：]]></content>
      <categories>
        
          <category> Common </category>
        
      </categories>
      <tags>
        
          <tag> MySQL </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
